from langchain_community.document_loaders import PyPDFLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain_community.vectorstores import FAISS
from langchain.chains import RetrievalQA
from langchain.llms import OpenAI  # or your preferred LLM
import requests
import tempfile
import os
from typing import List, Dict

class LangChainPDFRAG:
    def __init__(self, llm_model=None):
        """
        Initialize LangChain-based RAG system
        """
        self.embeddings = HuggingFaceEmbeddings(
            model_name="sentence-transformers/all-MiniLM-L6-v2"
        )
        self.text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=1000,
            chunk_overlap=200,
            length_function=len,
        )
        self.vector_stores = {}  # Cache for each zone
        self.llm = llm_model or OpenAI(temperature=0)
    
    def load_pdf_from_url(self, pdf_url: str) -> List:
        """
        Load and process PDF from URL using temporary file
        
        Args:
            pdf_url: URL of the PDF document
            
        Returns:
            List of document chunks
        """
        try:
            # Download PDF to temporary file
            response = requests.get(pdf_url)
            response.raise_for_status()
            
            with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf') as tmp_file:
                tmp_file.write(response.content)
                tmp_file_path = tmp_file.name
            
            # Load PDF using LangChain
            loader = PyPDFLoader(tmp_file_path)
            documents = loader.load()
            
            # Clean up temporary file
            os.unlink(tmp_file_path)
            
            # Split documents into chunks
            chunks = self.text_splitter.split_documents(documents)
            
            return chunks
            
        except Exception as e:
            print(f"Error loading PDF from {pdf_url}: {str(e)}")
            return []
    
    def create_vector_store(self, zone_code: str, pdf_url: str):
        """
        Create and cache vector store for a zone
        
        Args:
            zone_code: Zone identifier
            pdf_url: URL of the zone PDF
        """
        if zone_code in self.vector_stores:
            print(f"Vector store for zone {zone_code} already exists")
            return
        
        print(f"Creating vector store for zone {zone_code}...")
        
        # Load and process PDF
        documents = self.load_pdf_from_url(pdf_url)
        
        if not documents:
            print(f"No documents loaded for zone {zone_code}")
            return
        
        # Create vector store
        vector_store = FAISS.from_documents(documents, self.embeddings)
        self.vector_stores[zone_code] = vector_store
        
        print(f"Vector store created for zone {zone_code} with {len(documents)} chunks")
    
    def query_zone(self, zone_code: str, query: str, k: int = 3) -> str:
        """
        Query specific zone using RAG
        
        Args:
            zone_code: Zone to query
            query: User query
            k: Number of relevant documents to retrieve
            
        Returns:
            Generated response
        """
        if zone_code not in self.vector_stores:
            return f"Zone {zone_code} documents not available. Please process the zone first."
        
        # Create retrieval chain
        qa_chain = RetrievalQA.from_chain_type(
            llm=self.llm,
            chain_type="stuff",
            retriever=self.vector_stores[zone_code].as_retriever(search_kwargs={"k": k}),
            return_source_documents=True
        )
        
        # Execute query
        result = qa_chain({"query": query})
        
        return result["result"]
    
    def multi_zone_query(self, zone_codes: List[str], query: str) -> str:
        """
        Query multiple zones and combine results
        
        Args:
            zone_codes: List of zones to query
            query: User query
            
        Returns:
            Combined response from all zones
        """
        responses = []
        
        for zone_code in zone_codes:
            if zone_code in self.vector_stores:
                response = self.query_zone(zone_code, query)
                responses.append(f"**Zone {zone_code}:**\n{response}")
        
        if not responses:
            return "No zone information available for the specified zones."
        
        return "\n\n".join(responses)

# Integration example
class EnhancedZoneAgent:
    def __init__(self):
        self.rag_system = LangChainPDFRAG()
        self.zone_urls = {
            "H3": "https://unitaryplan.aucklandcouncil.govt.nz/images/Auckland%20Unitary%20Plan%20Operative/Chapter%20H%20Zones/H3%20Residential%20-%20Single%20House%20Zone.pdf",
            # Add more zones as needed
        }
    
    def setup_zones(self, zone_codes: List[str]):
        """
        Initialize vector stores for specified zones
        """
        for zone_code in zone_codes:
            if zone_code in self.zone_urls:
                self.rag_system.create_vector_store(zone_code, self.zone_urls[zone_code])
    
    def process_user_request(self, address: str, user_query: str) -> str:
        """
        Process user request with address and query
        """
        # Your existing zone detection logic
        detected_zones = self.detect_zones(address)
        
        # Setup zones if not already done
        self.setup_zones(detected_zones)
        
        # Generate response
        response = self.rag_system.multi_zone_query(detected_zones, user_query)
        
        return f"Information for {address}:\n\n{response}"
    
    def detect_zones(self, address: str) -> List[str]:
        """
        Your existing zone detection implementation
        """
        # Replace with your actual zone detection logic
        return ["H3"]

# Usage example
if __name__ == "__main__":
    agent = EnhancedZoneAgent()
    
    # Example usage
    address = "123 Main Street, Auckland"
    query = "What are the height restrictions for buildings?"
    
    response = agent.process_user_request(address, query)
    print(response)